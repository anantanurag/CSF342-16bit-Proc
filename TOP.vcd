$date
	Wed Apr 04 20:43:42 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_TOP $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module uut $end
$var wire 1 # A1_Out $end
$var wire 1 $ A2_Out $end
$var wire 1 % C_MemToReg $end
$var wire 1 & C_RegDstWrite $end
$var wire 1 ' C_RegWrite $end
$var wire 16 ( D_USE_Out [15:0] $end
$var wire 16 ) IR_InstructionOut [15:0] $end
$var wire 1 * NZERO $end
$var wire 1 + O1_Out $end
$var wire 1 , PCEnableWrite $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 - sign_extend $end
$var wire 1 . ZERO_OUT $end
$var wire 1 / RegWriteDst $end
$var wire 1 0 RegWrite $end
$var wire 1 1 ReadR2 $end
$var wire 2 2 ReadR1 [1:0] $end
$var wire 16 3 PC_OUT [15:0] $end
$var wire 16 4 PC_IN [15:0] $end
$var wire 1 5 PCWrite $end
$var wire 2 6 PCSrc [1:0] $end
$var wire 1 7 PCBNqCond $end
$var wire 1 8 PCBEqCond $end
$var wire 4 9 OPCODE [3:0] $end
$var wire 1 : MemWrite $end
$var wire 1 ; MemToReg $end
$var wire 1 < MemRead $end
$var wire 16 = MDR_OUT [15:0] $end
$var wire 16 > MDR_IN [15:0] $end
$var wire 1 ? IRWrite $end
$var wire 4 @ FUNCFIELD [3:0] $end
$var wire 16 A D_SE_Out [15:0] $end
$var wire 16 B D_RegSW [15:0] $end
$var wire 16 C D_ReadReg2RT [15:0] $end
$var wire 16 D D_ReadReg1RT [15:0] $end
$var wire 16 E D_Offset [15:0] $end
$var wire 16 F D_L1S_Out [15:0] $end
$var wire 16 G D_JUMP_SE_Out [15:0] $end
$var wire 16 H D_Instruction [15:0] $end
$var wire 16 I D_BT [15:0] $end
$var wire 4 J A_WriteRegRT_BT [3:0] $end
$var wire 4 K A_RegSWLW [3:0] $end
$var wire 4 L A_ReadReg2RT [3:0] $end
$var wire 4 M A_ReadReg1RT [3:0] $end
$var wire 4 N A_Offset [3:0] $end
$var wire 2 O A_2bit_RegSWLW [1:0] $end
$var wire 2 P A_2bit_Offset [1:0] $end
$var wire 3 Q ALU_OP [2:0] $end
$var wire 16 R ALU_2_IN [15:0] $end
$var wire 16 S ALU_1_IN [15:0] $end
$var wire 3 T ALUSrcB [2:0] $end
$var wire 1 U ALUSrcA $end
$var wire 16 V ALUOUT_OUT [15:0] $end
$var wire 16 W ALUOUT_IN [15:0] $end
$scope module ALU_MAIN $end
$var wire 16 X b [15:0] $end
$var wire 3 Y alu_op [2:0] $end
$var wire 16 Z a [15:0] $end
$var reg 16 [ out [15:0] $end
$var reg 1 . z $end
$upscope $end
$scope module AO $end
$var wire 16 \ ALUOUT_IN [15:0] $end
$var wire 1 ! clk $end
$var reg 16 ] ALUOUT_OUT [15:0] $end
$upscope $end
$scope module DM $end
$var wire 16 ^ A_DataAddress [15:0] $end
$var wire 1 " rst $end
$var wire 16 _ D_WriteData [15:0] $end
$var wire 1 : C_DMWrite $end
$var wire 1 < C_DMRead $end
$var reg 16 ` D_Data [15:0] $end
$upscope $end
$scope module FSM_Main $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 4 a opcode [3:0] $end
$var wire 4 b func_field [3:0] $end
$var reg 3 c ALUOp [2:0] $end
$var reg 1 U ALUSrcA $end
$var reg 3 d ALUSrcB [2:0] $end
$var reg 6 e CurrentState [5:0] $end
$var reg 1 ? IRWrite $end
$var reg 1 < MemRead $end
$var reg 1 ; MemToReg $end
$var reg 1 : MemWrite $end
$var reg 6 f NextState [5:0] $end
$var reg 1 8 PCBEqCond $end
$var reg 1 7 PCBNqCond $end
$var reg 2 g PCSrc [1:0] $end
$var reg 1 5 PCWrite $end
$var reg 2 h ReadR1 [1:0] $end
$var reg 1 1 ReadR2 $end
$var reg 1 0 RegWrite $end
$var reg 1 / RegWriteDst $end
$var reg 1 - sign_extend $end
$upscope $end
$scope module IM $end
$var wire 1 i C_IMRead $end
$var wire 1 " rst $end
$var wire 16 j A_InstrAddress [15:0] $end
$var reg 16 k D_Instruction [15:0] $end
$upscope $end
$scope module IR $end
$var wire 1 ? C_IRWrite $end
$var wire 16 l D_MemData [15:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var reg 2 m A_Offset [1:0] $end
$var reg 4 n A_ReadReg1RT [3:0] $end
$var reg 4 o A_ReadReg2RT [3:0] $end
$var reg 2 p A_RegSWLW [1:0] $end
$var reg 4 q A_WriteRegRT_BT [3:0] $end
$var reg 16 r D_Instr [15:0] $end
$var reg 4 s FUNCFIELD [3:0] $end
$var reg 4 t OPCODE [3:0] $end
$upscope $end
$scope module MDR $end
$var wire 16 u MDR_IN [15:0] $end
$var wire 1 ! clk $end
$var reg 16 v MDR_OUT [15:0] $end
$upscope $end
$scope module MPA $end
$var wire 1 U C_ALUSrc_A $end
$var wire 3 w C_ALUSrc_B [2:0] $end
$var wire 2 x C_RegDstRead1R [1:0] $end
$var wire 1 1 C_RegDstRead2R $end
$var wire 1 - C_SignExtend $end
$var wire 16 y D_USE_Out [15:0] $end
$var wire 16 z PC [15:0] $end
$var wire 16 { D_SE_Out [15:0] $end
$var wire 16 | D_RegSW [15:0] $end
$var wire 16 } D_ReadReg2RT [15:0] $end
$var wire 16 ~ D_ReadReg1RT [15:0] $end
$var wire 16 !" D_Offset [15:0] $end
$var wire 16 "" D_L1S_Out [15:0] $end
$var wire 16 #" D_JUMP_SE_Out [15:0] $end
$var wire 16 $" D_BT [15:0] $end
$var reg 16 %" ALU_1_IN [15:0] $end
$var reg 16 &" ALU_2_IN [15:0] $end
$var reg 16 '" M1_Out [15:0] $end
$var reg 16 (" M2_Out [15:0] $end
$var reg 16 )" M3_Out [15:0] $end
$upscope $end
$scope module MPC $end
$var wire 16 *" ALUOut_result [15:0] $end
$var wire 16 +" ALU_result [15:0] $end
$var wire 2 ," C_PCSource [1:0] $end
$var wire 16 -" RF_result [15:0] $end
$var reg 16 ." PC_IN [15:0] $end
$upscope $end
$scope module ProgCount $end
$var wire 1 , C_PCWrite $end
$var wire 16 /" PC_IN [15:0] $end
$var wire 1 ! clk $end
$var reg 16 0" PC_OUT [15:0] $end
$upscope $end
$scope module RF $end
$var wire 4 1" A_ReadReg1RT [3:0] $end
$var wire 4 2" A_ReadReg2RT [3:0] $end
$var wire 4 3" A_WriteRegRT_BT [3:0] $end
$var wire 1 % C_MemToReg $end
$var wire 1 & C_RegDstWrite $end
$var wire 1 ' C_RegWrite $end
$var wire 16 4" D_ALU_IN [15:0] $end
$var wire 16 5" D_MDR_IN [15:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 4 6" A_RegSWLW [3:0] $end
$var wire 4 7" A_Offset [3:0] $end
$var reg 16 8" D_BT [15:0] $end
$var reg 16 9" D_Offset [15:0] $end
$var reg 16 :" D_ReadReg1RT [15:0] $end
$var reg 16 ;" D_ReadReg2RT [15:0] $end
$var reg 16 <" D_RegSW [15:0] $end
$var reg 4 =" a_write [3:0] $end
$var reg 16 >" d_write [15:0] $end
$upscope $end
$scope module c10 $end
$var wire 2 ?" instr10to11 [1:0] $end
$var wire 4 @" c10out [3:0] $end
$upscope $end
$scope module c11 $end
$var wire 2 A" instr9to8 [1:0] $end
$var wire 4 B" c11out [3:0] $end
$upscope $end
$scope module l1bs $end
$var wire 16 C" SE_Out [15:0] $end
$var wire 16 D" L1S_Out [15:0] $end
$upscope $end
$scope module se12t16b $end
$var wire 12 E" instr11to0 [11:0] $end
$var wire 16 F" JUMP_SE_Out [15:0] $end
$upscope $end
$scope module se8t16b $end
$var wire 8 G" instr7to0 [7:0] $end
$var wire 16 H" SE_Out [15:0] $end
$upscope $end
$scope module use8t16b $end
$var wire 16 I" USE_Out [15:0] $end
$var wire 8 J" instr7to0 [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bz J"
b0zzzzzzzz I"
bx H"
bx G"
bx F"
bx E"
bx0 D"
bx C"
b11xx B"
bx A"
b10xx @"
bx ?"
bx >"
bx ="
bx <"
bx ;"
bx :"
bx 9"
bx 8"
b10xx 7"
b11xx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
b0 /"
b0 ."
bx -"
bx ,"
b0 +"
bx *"
b0 )"
b0 ("
b0 '"
b0 &"
b0 %"
bx $"
bx #"
bx0 ""
bx !"
bx ~
bx }
bx |
bx {
bx z
b0zzzzzzzz y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
1i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
b0 \
b0 [
b0 Z
bx Y
b0 X
b0 W
bx V
xU
bx T
b0 S
b0 R
bx Q
bx P
bx O
b10xx N
bx M
bx L
b11xx K
bx J
bx I
bx H
bx G
bx0 F
bx E
bx D
bx C
bx B
bx A
bx @
x?
bx >
bx =
x<
x;
x:
bx 9
x8
x7
bx 6
x5
b0 4
bx 3
bx 2
x1
x0
x/
z.
x-
x,
x+
x*
bx )
b0zzzzzzzz (
z'
z&
z%
x$
x#
x"
0!
$end
#10
b0 V
b0 ]
b0 ^
b0 *"
b0 4"
1!
#20
0!
#30
1!
#40
0!
#50
1!
#60
0!
#70
1!
#80
0!
#90
1!
#100
bx 4
bx ."
bx /"
bx W
bx [
bx \
bx +"
x*
b10 R
b10 X
b10 &"
bx S
bx Z
bx %"
x.
0+
1,
0$
0#
00
0?
0<
0:
15
07
08
b1 T
b1 d
b1 w
0U
b0 Q
b0 Y
b0 c
b0 6
b0 g
b0 ,"
b1 f
b0 e
b0 >
b0 `
b0 u
b0 H
b0 k
b0 l
0!
1"
#110
bx V
bx ]
bx ^
bx *"
bx 4"
b0 =
b0 v
b0 5"
b0 J
b0 q
b0 3"
b1100 K
b1100 6"
b1100 B"
b0 O
b0 p
b0 A"
b1000 N
b1000 7"
b1000 @"
b0 P
b0 m
b0 ?"
b0 L
b0 o
b0 2"
b0 M
b0 n
b0 1"
b0 @
b0 b
b0 s
b0 9
b0 a
b0 t
b1 f
1!
#120
0!
#130
b0 f
1!
#140
0!
#150
1!
#160
0!
#170
1!
#180
0!
#190
1!
#200
b0 I
b0 $"
b0 -"
b0 8"
b0 B
b0 _
b0 |
b0 <"
b0 E
b0 !"
b0 9"
b0 C
b0 }
b0 ;"
b0 D
b0 ~
b0 :"
bx ="
bx H
bx k
bx l
0!
0"
#210
bx ="
1!
#220
0!
#230
bx ="
1!
#240
0!
#250
bx ="
1!
#260
0!
#270
bx ="
1!
#280
0!
#290
bx ="
1!
#300
